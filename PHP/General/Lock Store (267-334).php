            $result = $client->evalSha($scriptSha, array_merge([$resource], $args), 1);
            if (null !== ($err = $client->getLastError()) && str_starts_with($err, self::NO_SCRIPT_ERROR_MESSAGE_PREFIX)) {
                $client->clearLastError();

                $client->script('LOAD', $script);

                if (null !== $err = $client->getLastError()) {
                    throw new LockStorageException($err);
                }

                $result = $client->evalSha($scriptSha, array_merge([$resource], $args), 1);
            }

            if (null !== $err = $client->getLastError()) {
                throw new LockStorageException($err);
            }

            return $result;
        }

        \assert($this->redis instanceof \Predis\ClientInterface);

        try {
            return $this->handlePredisError(fn () => $this->redis->evalSha($scriptSha, 1, $resource, ...$args));
        } catch (LockStorageException $e) {
            // Fallthrough only if we need to load the script
            if (!str_starts_with($e->getMessage(), self::NO_SCRIPT_ERROR_MESSAGE_PREFIX)) {
                throw $e;
            }
        }

        if ($this->redis->getConnection() instanceof \Predis\Connection\Cluster\ClusterInterface) {
            foreach ($this->redis as $connection) {
                $this->handlePredisError(static fn () => $connection->script('LOAD', $script));
            }
        } else {
            $this->handlePredisError(fn () => $this->redis->script('LOAD', $script));
        }

        return $this->handlePredisError(fn () => $this->redis->evalSha($scriptSha, 1, $resource, ...$args));
    }

    private function getUniqueToken(Key $key): string
    {
        if (!$key->hasState(__CLASS__)) {
            $token = base64_encode(random_bytes(32));
            $key->setState(__CLASS__, $token);
        }

        return $key->getState(__CLASS__);
    }

    private function getNowCode(): string
    {
        if (!isset($this->supportTime)) {
            // Redis < 5.0 does not support TIME (not deterministic) in script.
            // https://redis.io/commands/eval#replicating-commands-instead-of-scripts
            // This code asserts TIME can be use, otherwise will fallback to a timestamp generated by the PHP process.
            $script = '
                local now = redis.call("TIME")
                redis.call("SET", KEYS[1], "1", "PX", 1)

	            return 1
            ';
            try {
                $this->supportTime = 1 === $this->evaluate($script, 'symfony_check_support_time', []);
            } catch (LockStorageException $e) {
                if (!str_contains($e->getMessage(), 'commands not allowed after non deterministic')